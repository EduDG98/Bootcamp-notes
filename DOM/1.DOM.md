# 1. DOM üå≥

**√çNDICIE**

1. [¬øQu√© es el DOM?](#dom)
2. [DOM _Navigation_](#navigation)
   1. [Buscar etiquetas HTML](#buscar)
      1. [_HTMLCollection_ / _NodeList_](#nodelist)
      2. [Elementos modernos](#modernos)
   2. [Crear elementos HTML]

# ¬øQu√© es el DOM?

- El _Document Object Model_ crea una representaci√≥n / modelo con objectos de la p√°gina web.
- Crea un objecto / nodo de cada elemento HTML
- El DOM no forma parte de HTML o JS, son una reglas a parte.
- Controla qu√© scripts pueden acceder al navegador y como actualizarlo.
- Los nodos del DOM se les llama "**_DOM querries_**".

## Objecto _document_

- Es la forma de acceder al DOM.
- Representa el _DOM tree_.

# DOM Navigation

## Buscar etiquetas:

- Se puede acceder a los elementos HTML v√≠a _id_, _class_ o por el _tag_ (etiqueta HTML)
  - `getElementById('nombre')` --> coge el elemento con el **_id_** nombre.
  - `getElementsByClassName('nombre')` --> coge todos los elementos con el **_className_** nombre.
  - `getElementsByTagName('div')` --> coge todos los **_elemento HTML_** que son _divs_.
- <u>Ejemplo:</u>
  ```javascript
  const elementOne = document.getElementById("element1");
  const containerElement = document.getElementsByclassName("container");
  const divItems = document.getElementsByTagName("div");
  ```

> Puede haber m√°s de una clase y _tag_. Pero no m√°s de un _id_.
> Al acceder a m√°s de un elemento se obtiene un _array_.
> Pero si no encuentra el elemento o clase, devuelve un _array_ vac√≠o.

## _HTMLCollection_ / _NodeList_

- El _DOM tree_ est√° formado por elmentos y nodos.
  - **elementos**: representan las etiquetas.
  - **nodos**:
    - es la unidad b√°sica en el DOM.
    - un nodo puede ser un elemento (etiqueta HTML) √≥ texto
- Los m√©todos que devuelven m√°s de un elemento, no devuelven un _array_ sino un/a:
  - _HTMLCollection_ --> si se usa `getElementBy...`
  - _NodeList_. --> si se usa `querySelector()`

### Convertir a _array_

- Si se quieren los elementos en un _array_ en vez de en un **_HTMLCollection_**.
- Hay que usar [[2. Destructuraci√≥n üß±]], con los _spread operator_ o el `Array.from( ... )`
- <u>Ejemplo:</u>
  `javascript
const containerElement = [...document.getElementsByclassName('container')];
`
  > Ahora se pueden usar los [[1. M√©todos de Arrays üíº]]

## üî∂ M√©todos modernos

- Son selectores de CSS
  - üî∏`querySelector(' ... ')` --> devuelve el primer elemento.
  - üî∏`querySelectorAll(' ... ')` --> devuelve todos los elementos.
- Se accede:
  - Para _id_ se accede con el `.` + nombre de la clase.
  - Para clase se accede con el `#` + _id_
- <u>Ejemplo:</u>

  ```javascript
  const idElement = document.querySelector("#myId");
  const classElement = document.querySelector(".myClass");
  const infoElement = document.querySelector(".myClass .info"); // La clase info que esta dentro de myClass.

  const allClassElements = document.querySelectorsAll(
    ".myClass #container .row"
  );
  ```

````

### Selectores CSS
- Con *querySelector()* se puede usar selectores de CSS simples y avanzados.
- <u>Ejemplo:</u>
	```javascript
	const nicknames = document.querySelector('[name="nick"]');  // Devuelve los elementos con el atributo name='nick'
````

## Crear elementos HTML

- Para crear o clonar un elemento se utiliza:

### üî∂`createElement()`

- Crea un elemento HTML pero no lo inserta en el documento HTML.
- <u>Ejemplo:</u>
  ```js
  const divElement = document.createElement("div");
  const spanElement = document.createElement("span");
  ```

### `cloneNode()`

- Para clonar elementos HTML.
- No se puede usar `createElement()` para copiar elementos porque act√∫a como un puntero.
- <u>Sintaxis:</u>
  ```js
  const newNode = node.clonesNode(deep);
  ```
  - `node` --> node a clonar.
  - `deep`
    - `true` --> para clonar tambi√©n los hijos.
    - `false` --> no clonar los hijos.

### `isConnected`

- Devuelve un _boolean_ si la propiedad est√° conectada al DOM.

## Atributos de elementos HTML

- Una vez se crea un elemento, se le a√±ade, quita o accede a atributos con:

  - üî∏`.id` --> a√±adir un _id_.
  - `.className` --> a√±adir un _className_.
    - <u>Ejemplo:</u>
      ```js
      const div = document.createElement("div");
      div.className = "row";
      ```
  - `.style` --> para a√±adirle una _prop._ de CSS y darle estilo.
  - üî∏`.classList(' ... ')` --> a√±ade una o m√°s clases.
  - `.hasAttributes()` --> si tiene atributos.
  - `.hasAttribute( attr )` --> si tiene el atritubto _attr_.
  - `.getAttributeNames()` --> devuelve un array con los attributos.
  - `.getAttribute( attr )` --> devuelve el valor del attributo _attr_.
  - `.removeAttribute( attr )` --> elimina el atributo _attr_.
  - `.setAttribute( attr, value)` --> cambie el valor del atributo _attr_ por _value_. (Si no existe el atributo lo crea)

  - `.getAttributeNode( attr )` --> devuelve el atributo _attr_ como nodo.
  - `.removeAttributeNode( attr )`
  - `.setAttributeNode( attr, value )`

## Fragmentos

- Es un documento paralelo sin elemento padre.
- Se usa cuando hay que hacer muchos cambios consecutivos.
- Despu√©s de actualizarlo se a√±ade al DOM y el **fragmento** queda vac√≠o de nuevo.
- <u>Sintaxis:</u>
  ```js
  const myFragmen = document.createDocumentFragment();
  ```

## Insertar, reemplazar o eliminar etiquetas en el DOM

### <u>Reemplazar elementos</u>:

- `nodeName` --> Solo lectura. Devuelve el tipo de elemento (en may√∫sculas)
- üî∏`textContent` --> Devuelve o se modifica el texto del elemento.
- üî∏`innerHTML` --> Devuelve o se modifica el contenido HTML (Aparte de texto tambi√©n puede a√±adir etiquetas HTML).
- `outerHTML` --> Igual que _innerHTML_ pero sustituye o devuelve el elemento HTML del pr√≥pio elemento (al que se le aplica el m√©todo por una etiqueta HTML nueva)

> Si el elemento HTML est√° ocultado con CSS no podemos acceder al contenido con `textContent()`, pero **s√≠** con `innerHTML()`

### <u>Insertar elemetos</u>:

- Despu√©s de crear los elementos HTML con `createElement()` hay que insetarlos al DOM.
- M√©todos:

  - üî∏*ParentNode*`.appendChild(node)` --> a√±ade como **√∫ltimo** hijo el node _node_ al _ParentNode_.

- M√©todos para insertar en una posici√≥n espec√≠fica:
  - `.insertAdjacentElement(pos, elem)` --> a√±ade el **elemento** HTML _elem_ en la posici√≥n _pos_.
  - `.insertAdjacentHTML(pos, str)` --> a√±ade el **c√≥digo HTML** _str_ en la posici√≥n _pos_.
  - `.insertAdjacentText(pos, text)` --> inserta **texto** en la posici√≥n.
    - **_pos_** es una _String_ que puede ser:
      - `beforebegin` --> el elemento se inserta antes de la etiqueta de apertura.
      - `afterbegin` --> dentro de la etiqueta pero antes del primer hijo.
      - `beforeend` --> despu√©s del √∫ltimo hijo.
      - `afterend` --> despu√©s de la etiqueta de cierre.
  - `.insertBefore(new, node)` --> inserta el nodo _new_ antes del nodo _node_.

### <u>Eliminar elementos</u>

- En realidad no se elimina, se desconecta del DOM.
- M√©todos:
  - `remove()` --> el elemento se desconecta a si mismo del DOM.
  - _ParentNode_`.removeChild(node)` --> eliminar del padre el nodo hijo _node_.
  - `repalceChild(new, old)`

## Gesti√≥n de CSS

### üî∂`classList`

- Se pueden a√±adir varias clases, una _DOMTokenList_ de clases.
- M√©todos de `classList`:

  - `.length `
  - `.add( 'newClass', 'otherClass', ... )`

    - Para a√±adir un _array_ de clases hay que usar [[2. Destructuraci√≥n üß±]].

      - <u>Ejemplo:</u>
        ```js
        myDiv.classList.add(...["selected", "otherClass"]);
        ```

  - `.item(n)` --> accede a una clases concreta en la posici√≥n _n_ del elemento al que se le aplica.
  - `.values` --> devuelve una sola _String_ con las clases del elemento.
  - `.remove(' ... ')`
  - `.contains(' ... ')`
  - `.toggle(' ... ')` --> si tiene la clase se la quita y sino se la a√±ade.
  - `.replace('oldClass', 'newClass')`

## Navegador por _tags_, elementos.

- Porpiedades para elementos:

  - `children` --> devuelve un _array_ de elementos HTML hijos.
  - `parentElement` --> devuelve el padre del elemento (si no tiene es _null_)
  - `firstElementChild` --> el primer elemento hijo (`childre[0]`)
  - `lastElementChild`
  - `previousElementSibling` --> el elemento hermano que esta anterior (si no tiene _null_)
  - `nextElementSibling` --> el elemento hermano siguiente.

- Propiedades para nodos:
  - `childNodes`
  - `parentNode`
  - `firstChild`
  - `lastChild`
  - `previousSibling`
  - `nextSibling`
